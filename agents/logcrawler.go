package agents

import (
	"context"
	"fmt"
	"strings"

	"github.com/firebase/genkit/go/ai"
	"github.com/firebase/genkit/go/core"
	"github.com/firebase/genkit/go/genkit"
	"github.com/firebase/genkit/go/plugins/googlegenai"

	"github.com/paramite/zuulusi/tools"
)

const agentModel = "googleai/gemini-2.5-pro"

type LogCrawlerInput struct {
	JobID             string
	ImportantDirs     []string
	MinimumOccurences string
}

// LogCrawlerAgent browses contents of log files generated by a CI job and finds all possible root causes of it's failure.
func LogCrawlerAgent(g *genkit.Genkit) *core.Flow[LogCrawlerInput, string, struct{}] {
	return genkit.DefineFlow(g, "logCrawlerAgent", func(ctx context.Context, input LogCrawlerInput) (string, error) {
		if g == nil {
			return "", fmt.Errorf("flow context initialization")
		}
		model := googlegenai.GoogleAIModel(g, agentModel)

		curlTool := genkit.DefineTool(g, "curl", "Downloads content of single file.", tools.CurlTool())
		if curlTool == nil {
			return "", fmt.Errorf("curl tool not defined")
		}

		dirCrawlerTool := genkit.LookupTool(g, "dircrawler")
		if dirCrawlerTool == nil {
			return "", fmt.Errorf("directory crawler tool not defined")
		}

		important := strings.Join(input.ImportantDirs, ", ")

		fmt.Printf("Searching for a cause of job %s failure with priority paths containing following strings in log path %s with minimum of %s occurences.\n",
			input.JobID, important, input.MinimumOccurences)

		msg := ai.NewSystemMessage(ai.NewTextPart(
			"You are a system administrator looking out for errors in log files to identify the root cause of failed CI job. " +
				"You list log files of the given job and examine those files. " +
				"You must use the provided dirCrawler tool for listing available log files." +
				"You must use the provided curl tool for downloading log file content." +
				"You don't need to download and examine all the log files in the given directory structure. " +
				"You must start to examinethe most important log files first. The most important log files are those that contain " +
				"at least two of the following strings in it's directory path or file name: " +
				fmt.Sprintf("%s. ", important) +
				"Stop with log examination and generate the response once root cause is acknowledged " +
				fmt.Sprintf("with at least %s occurences of the issue.", input.MinimumOccurences) +
				"In your final response, list all found errors and files where you found them."))

		resp, err := genkit.Generate(ctx, g,
			ai.WithModel(model),
			ai.WithMessages(msg),
			ai.WithTools(curlTool, dirCrawlerTool),
			ai.WithToolChoice(ai.ToolChoiceAuto),
			ai.WithMaxTurns(50),
			ai.WithPrompt(fmt.Sprintf("Summarize the potential cause of the issue in job '%s'.", input.JobID)),
		)

		if err != nil {
			return "", fmt.Errorf("error generating response: %w", err)
		}

		// Extract the final text response
		response := resp.Text()
		if response == "" {
			return "", fmt.Errorf("error generating response: empty response content")
		}

		return response, nil
	})
}
